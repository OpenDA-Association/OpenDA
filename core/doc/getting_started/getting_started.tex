\svnidlong
{$HeadURL: $}
{$LastChangedDate: $}
{$LastChangedRevision: $}
{$LastChangedBy: $}

\odachapter{Getting started with \oda}

\begin{tabular}{p{4cm}l}
\textbf{Contributed by:} & \\
\textbf{Last update:}    & \svnfilemonth-\svnfileyear\\
\end{tabular}

\section{Introduction}
\oda is a generic environment for data-assimilation tasks like parameter calibration and measurement filtering. It provides a platform that allows an easy interchange of algorithms and models.

It is a modular framework, containing methods and tools that can be used for a wide range of applications. By offering the data-assimilation software as a separate component, the cost of applying data-assimilation methods in one's project is reduced. At the same time, it allows new developments in the field of data assimilation to quickly spread to all applications that might benefit from it.

We assume that the reader is familiar with computational modeling, and with the principal aspects of data assimilation: the distinction between offline and on\-line methods, the statistical framework used, the notions of deterministic and stochastic models, and the general structure of filtering methods. 

\section{Installing and running \oda}\label{sec:installation}
The first thing that needs to be taken care of is the installation of \oda. Please read the appropriate installation section to see how that is done and whether it is done properly. We offer installation instructions for Linux, Mac and Windows. The following instructions hold for all platforms: 
\begin{itemize}
\item Ensure that a 64-bit Java version 1.8 or higher is installed on your computer. You can check which version is installed through the \verb|java -version| command in a terminal or command window. We have tested our software with the jre from SUN. The easiest way to install Java is often with the package manager that comes with your distribution (e.g. APT, yum for Red Hat-, dpkg for Debian- or YaST for SUSE-related distributions), but you can also download the latest version from \href{http://www.java.com/download}{www.java.com/download}.
\item Download the \oda binaries from \href{https://github.com/OpenDA-Association/OpenDA/releases}{GitHub}. 
\item Extract the \oda distribution file to the desired location on your computer. On some Linux systems unzip/ark is not installed by default, in that case try the package manager again.  Note: \oda does not work when it is installed on a location with a space in the path (like "\verb|My Documents|").
\end{itemize}

\subsection{\oda installation for Linux users}
\textbf{Note about csh}

At the moment, scripts for csh and related shells are not included with the \oda distribution. It is possible to use \oda in conjunction with for instance tcsh, but you will have to convert the scripts yourself.

\textbf{Note about GNU C Library}

All native components of \oda (parts of the source code that need to be compiled to a specific platform (in this case Linux)) are compiled for both 32-bit and 64-bit versions of Linux. For 32-bit systems a GLIBC version 2.4 or higher is needed, for the 64-bit version 2.7 or higher. If you have an older version of GLIBC, you need to compile the libraries yourself. It is important to remove all \verb|.so| files in the \verb|lib| directory before building. 

\textbf{Step-by-step installation}

After having followed the general steps in Section \ref{sec:installation}, some Linux-specific steps should be executed.
\begin{itemize}
\item
A number of system variables need to be set before \oda can be run. The first variable that should be set is 
\verb|$OPENDADIR|. This variable should point to the \verb|bin| directory of your \oda installation. For example:
\begin{verbatim}
    export OPENDADIR=/myhome/openda/bin
\end{verbatim}
		
The other variables are set by the script \verb|settings_local.sh| in the directory \verb|$OPENDADIR|. This script will try to call a local script with machine-specific settings 
\begin{verbatim}
$OPENDADIR/settings_local_<hostname>.sh
\end{verbatim}
This script can be constructed by copying the \verb|settings_local_base.sh| file to a new file named \verb|settings_local_<hostname>.sh| in your \verb|$OPENDADIR| (unless that file already exists). You can check your hostname using the \verb|hostname| command. Then edit that file: enable the relevant lines and change the values of the environment variables.

For Linux there is a default local-settings script that might work out of the box for your system. You can use this script by
\verb|. $OPENDADIR/settings_local.sh linux|
\item
Most convenient is to have the variables set automatically. Add the following two lines to the \verb|.bashrc| file in your home directory:

\verb|export OPENDADIR=<bindir>|, with \verb|<bindir>| the location of the \verb|bin| directory of your \oda installation.

\verb|. $OPENDADIR/setup_openda.sh|

Note that the '.' is significant in the latter of these lines.
\end{itemize}


\textbf{Starting \oda}

In the folder \verb|<path_to_openda_release>/bin|, run \verb|oda_run.sh -gui| to open the \oda GUI. Optionally the path to the oda file can be supplied as an argument, which will open that \oda configuration (\verb|oda_run.sh -gui <path_to_oda_file>|).

\subsection{\oda installation for Mac users}
\textbf{Step-by-step installation}

After having followed the general steps in Section \ref{sec:installation}, some Mac-specific steps should be executed.
\begin{itemize}
\item A number of system variables need to be set before \oda can be run. The first variable that should be set is \verb|$OPENDADIR|. This variable should point to the \verb|bin| directory of your \oda installation. For example:

\verb|export OPENDADIR=/myhome/openda/bin|

The other variables are set by the \verb|settings_local.sh| script in the \verb|$OPENDADIR| directory. This script will attempt to call the local script with machine-specific settings \verb|$OPENDADIR/settings_local_<hostname>.sh|. This script can be constructed by copying the \verb|settings_local_mac.sh| file to \verb|settings_local_<hostname>.sh| in your \verb|$OPENDADIR| directory (unless that file already exists). You can check your hostname using the \verb|hostname| command. Then edit that file: enable the relevant lines and change the values of the environment variables.

The default local-settings script might work out of the box for your system. You can use this script by typing:

\verb|. \$OPENDADIR/settings_local.sh mac|
\item Most convenient is to have the variables set automatically. Add the following two lines to the \verb|.bashrc| file in your \verb|home| directory:

\verb|export OPENDADIR=<bindir>|, with \verb|<bindir>| the location of the \verb|bin| directory of your \oda installation.

\verb|. \$OPENDADIR/setup_openda.sh|

Note that the '.' is significant in the latter of these lines.
\end{itemize}

\textbf{Starting \oda}

In the folder \verb|<path_to_openda_release>/bin|, run \verb|oda_run.sh -gui| to open the \oda GUI. Optionally the path to the oda file can be supplied as an argument, which will open that \oda configuration (\verb|oda_run.sh -gui <path_to_oda_file>|).
\subsection{\oda installation for Windows users}
\textbf{Note about 64-bit systems}

Windows XP is a 32-bit operating system, but some versions of Windows Server, Windows Vista and Windows 7 are 64-bit operating systems and can install the 64-bit version of Java. All native components of \oda (parts of the source code that need to be compiled to a specific platform (in this case Windows)) are currently compiled for 32-bit versions of Windows only. If you need these native components on a 64-bit system, you have two options:
\begin{itemize}
\item Install a 32-bit version of Java.
\item Compile the native libraries on your machine, see \ref{dc:build:windows}.
\end{itemize}



\textbf{Starting \oda}

If you use the command line (\verb|cmd.exe|), then you can run the \oda GUI by running the \verb|oda_run_gui.bat| batch file in the folder \verb|<path_to_openda_release>/bin|. It is probably convenient to add the \verb|bin| directory within the \oda directory to the \verb|PATH| environment variable. Optionally the path to the oda file can be supplied as an argument, which will open that \oda configuration (\verb|oda_run_gui.bat <path_to_oda_file>|). The location of your system's Java Runtime Environment can be specified through \verb|-jre "<path_to_jre>"|. This should be the general Java folder (not the specific \verb|bin| directory in it).

\subsection{\oda examples}
You can find examples in the \verb|<path_to_openda_release>/examples| directory. An example that can easily be executed is found in

\verb|model_example_blackbox/blackbox_example_calibration/Dud.oda|

After opening this file in the GUI, you can run the simulation. 

For other examples in this folder, it might be necessary to connect to existing models. (TODO Erik)
\section{Using \oda}
The next step will be learning how to use \oda. At first, a brief introduction to data assimilation is presented. The next step is an introduction to \oda itself. After these introductions, you should be ready to start \oda, either from the command line or the graphical user interface (GUI). 

\subsection{Introduction to data assimilation}
Data assimilation is about the combination of two sources of information - computational models and observations - in order to utilize both of their strengths and compensate for their weaknesses.

Computational models are available nowadays for a wide range of applications: weather prediction, environmental management, oil exploration, traffic management and so on. They use knowledge of different aspects of reality, e.g. laws of physics, empirical relations, human behavior, etc., in order to construct a sequence of computational steps, by which simulations of different aspects of reality can be made.

The strengths of computational models are the ability to describe/forecast future situations (also to explore what-if scenarios), in a large amount of spatial and temporal detail. For instance weather forecasts are run at ECMWF using a horizontal resolution of about 50 km for the entire earth and a time step of 12 minutes. This is achieved with the tremendous computing power of modern-day computers, and with carefully-designed numerical algorithms.

However, computations are worthless if the system is not initialized properly: "Garbage in, garbage out". Furthermore the "state" of a computational model may deviate from reality more and more while running, because of inaccuracies in the model, aspects that are not considered or not modeled well, inappropriate parameter settings and so on. Observations or measurements are generally considered to be more accurate than model results. They always concern the true state of the physical system under consideration. On the other hand, the number of observations is often limited in both space and time.

The idea of data assimilation is to combine a model and observations, and optimally use the information contained in them.

\begin{itemize}
    \item offline versus online;
    \item combine values: weights needed;
    \item statistical framework, std.error;
    \item deterministic versus stochastic models;
    \item noise model;
    \item data assimilation on top of model.
\end{itemize}

\subsection{Introduction to \oda}
\oda is a generic environment for parameter calibration and measurement filtering. It provides a platform, where the interchange of algorithms as well as models can be done easily.

\oda is configured using XML (Extensible Markup Language) files, in which the information about the data-assimilation components is specified. For instance, if you would like to use a different calibration algorithm or stochastic observer, or if you would like to couple your own model to \oda, you should provide all necessary settings, file names, variable names etc. to \oda in XML input files. The format of the XML files is specified in XML schema files (\verb|.xsd|) that are hosted on the \href{http://openda.org/docu/openda_2.4/doc/xmlSchemasHTML/index.html}{\oda website}. The diagrams describing the format of the XML schemas can be found there as well. 

In general, the user needs to provide one main configuration file and a number of configuration files describing each data-assimilation component. The main configuration file contains references to the other components’ configuration files. Usually, there are three main data-assimilation components: stochastic model, stochastic observer, and algorithm. In addition, another component may be specified to configure how \oda output will be stored. 

The explanation of each configuration file is given below.

\begin{itemize}
    \item Main configuration file (XML schema: \verb|openDaApplication.xsd|) \\
          In the main configuration file, the \oda java class names, working directories and configuration file names of all the used data-assimilation components are specified.
    \item Stochastic observer \\
		In this configuration file, the user specifies the observation data used in the application as well as the information about its uncertainty.
    \item Stochastic model \\
		In this configuration file, the user specifies the model-related information.
    \item Algorithm \\
		In this configuration file, the user specifies the input parameters required by the data-assimilation or parameter-calibration algorithm being used.
\end{itemize}

\oda defines certain interfaces, which standardize how different components of \oda communicate with each other. For the model component, \oda defines two levels of interface: the \emph{model-instance interface} and the \emph{stochastic model-instance interface}. The model-instance interface defines functionality which a (deterministic) model should implement. On the other hand, the stochastic model-instance interface defines the stochastic extension of the deterministic model.

In order for a model to work within \oda, the model should be extended by implementing these interfaces. This is usually called \emph{wrapping the model}. There are at least five ways one can wrap a model:
\begin{itemize}
\item The first way is to write the model code from scratch in Java and deliberately design the code to match \oda's requirements. The distribution of \oda contains several of such models. Those are small (toy) models, which are developed to test and illustrate various applications of \oda. 
\item The second way is to combine native model code (related to the platform Linux/Mac/Win\-dows) with a wrapping Java extension. In this way, we keep the computation core of the model in its original code while extending it with an \oda wrapper. 
\item The third way is to write a model in Java, which implements only the (deterministic) model-instance interface, and to use the existing Stochastic black-box model utilities for its stochastic extension. The black-box model utilities are various functions in \oda for implementing the required interfaces, which are generic and independent from the actual model. Making use of these utilities reduces the work one has to do to wrap a model. 
\item The fourth way is like the third one, but the computation core of the model uses the native code. 
\item The fifth way is the simplest, most-used, and advised method to wrap a model: a full black-box model. In this way, one only needs to write several functions which read and/or write input and output files of the model. Once these methods are ready, one can simply use the black-box model utilities to create a complete stochastic-model extension required for a data-assimilation application. While it is the easiest way to implement, an application based on the black-box wrapper is the most computationally expensive. This is because the communication between the model and other \oda components is performed through writing and reading files. More information about the black-box configuration can be found in Chapter \ref{chap:bb}.
\end{itemize}

The configuration files for the stochastic model depend on the type of model. For the toy models which are installed by default with \oda, there is only one model-configuration file needed. On the other hand, three configuration files are required for black-box models: 
\begin{itemize}
\item The wrapper configuration: here, the user needs to provide generic information about the model like aliases used to describe the model, the execution steps of the model’s relevant executable, and about input-output Java classes used by \oda to communicate with this model.
\item The model configuration: here, specific information of the particular model is given.
\item The stochastic-model configuration: this file contains the information about vector specifications and may also contain information about the uncertainty of the model. 
\end{itemize}
Note that these three configuration files together are used to define the stochastic-model configuration that was mentioned above.

For the DLL-based models, the configuration files needed depend on the choices made by the programmers of the \oda wrapper. In principle, they will require configuration files, where users can specify the four configuration files mentioned above (one main configuration file, and three data-assimilation-related configuration files). 



\odachapter{Developers' corner: Java}\label{chap:Java}
For people who want to (or have to) start from the \oda source code, the Developers' corner is added. The developers' corner is split in two parts: a Java part (this chapter) and a native part (Chapter \ref{chap:native}. The term \emph{native} is used for parts of the source code that need to be compiled to a specific platform (Linux, Mac or Windows), formerly known as the Costa PSE.

TODO Erik: review this chapter, and add a section on IntelIJ.

\section{Building Java sources}
The \oda Java source code is located in the \verb|core/java| directory of the source distribution, but when building everything, \verb|Ant| can be run from the \oda root directory (it will use the \verb|build.xml| file located there).

\oda software consists of four main \emph{modules}. The first module is the \verb|core| module, which contains the core of the \oda software. The three other modules are named after the conceptual components of data assimilation: \verb|models|, \verb|observers|, and \verb|algorithms|. Each of these modules contain all programs and files related to the respective data-assimilation component. The \verb|core| module contains programs, which interface the other three modules. Modules for larger models with concrete applications are stored separately (\verb|model_*|).

Native libraries, written e.g. in C or Fortran are provided both as source and binaries with \oda. By default the build processes use the binaries. All binaries provided are 32-bit and therefore need a 32-bit version of Java. You can recompile the required native libraries as 64-bit if needed, for which you will need a 64-bit version of Java. For some blackbox-wrappers en small models you may not need any native libraries, so both 32-bit and 64-bit Java can be used.

\section{Installation of Ant}
To build \oda software, a command-line tool called \verb|Ant| is used. \verb|Ant| is similar to \verb|make|, but written in Java, so that it is portable between different platforms. If \verb|Ant| is not installed on your computer yet, you can download it from \href{http://ant.apache.org/bindownload.cgi}{ant.apache.org/bindownload.cgi}. For Linux users it is probably easier to use their package manager to install \verb|Ant|. Before installing \verb|Ant|, please check that a recent 32-bit version of Java is installed (which can be downloaded from \href{http://www.java.com/download}{www.java.com/download} or in case of Linux, installed with the package manager).

\section{Build commands}
For the following description it is assumed that the \oda source is available in a directory named \verb|<path_to_openda>/public| .
Start by opening a command shell (Linux) or a command window (Windows) and change directory to the \oda main directory.

\subsection{Compiling \oda}
From the \oda main directory, you can compile all modules at once. Besides compilation there are several other options:
\begin{itemize}
\item \verb|ant| (without any argument): to show help with a list of possible \verb|ant| arguments (the same as \verb|ant help|).
\item \verb|ant build|: to compile \oda, make \verb|jar| files and copy resources. This doesn't generate \verb|Javadoc| documentation.
\item \verb|ant doc|: to build \verb|Javadoc| documentation for all modules and collect this documentation.
\item \verb|ant clean|: to remove the generated files.
\item \verb|ant zip|: to compile \oda, collect documentation and XML schemas and create a set of zip files which contain the subversion revision number in the filename as well as in the name of the readme file. This makes it easy to wrap everything for exporting to a website or user. Exports with the same version numbers will extract to the same \verb|openda_<version>| directory, but new versions can coexist.
\item \verb|ant zip-tests|: to create zip files for the various test cases. Each case is stored as separate zip file. Each file is named after the case followed by the version number.
\end{itemize}

\subsection{Compiling individual components}
From the module directory (\verb|core|, \verb|models|, \verb|model_*|, \verb|observers|, or \verb|algorithms|), you can compile a single module. Within a module directory the build file has somewhat different options:

\begin{itemize}
\item \verb|ant| (without any argument): to show help with a list of possible \verb|ant| arguments.
\item \verb|ant build|: to compile the module, make \verb|jar| files and copy resources. This doesn't generate \verb|Javadoc| documentation.
\item \verb|ant javadoc|: to build \verb|Javadoc| documentation.
\item \verb|ant clean|: to remove the generated files.
\item \verb|ant make-standalone|: copy required external binaries to the module directory.
\end{itemize}

\subsection{Compiling stand-alone modules}
When providing others with a stand-alone module, you will have to provide other modules your stand-alone module depends upon (if any). The easiest way to achieve this, is by using \verb|ant make-standalone| (after building all \oda modules) in the module directory. This will copy the files needed to the module directory.

\section{Directory structure}
Upon the execution of the command \verb|ant build| or \verb|ant doc|, the following folders are created in the main directory:

\begin{itemize}
\item \verb|bin|: contains all binary files required for running \oda. This will be the content of an \oda distribution file.
\item \verb|doc|: contains \oda documentation, including some examples.
\item \verb|xmlSchemas|: contains the XML Schema files for the \oda configuration files.
\end{itemize}

Each module directory has the following structure:

\begin{itemize}
\item \verb|bin|: contains all binary files related to the respective module.
\item \verb|build|: contains the class files resulting from compiling the Java files of the respective module.
\item \verb|javadoc|: will contain Java documentation files when they are generated by executing \verb|ant javadoc| on the command line.
\end{itemize}

\section{Removal of generated files}
To remove the files generated by a build, you can use \verb|ant clean| on the command line. From within a module directory, this command will remove the \verb|bin|, \verb|build| and \verb|javadoc| directories, and the \verb|MANIFEST.MF| file\footnote{This file contains meta information about the used JDK version etc.}. It does not affect other modules nor the folder \verb|bin| in the \oda main directory. Executing the command line \verb|ant clean| from the \oda main directory will delete the folders \verb|bin|, \verb|doc|, and \verb|xmlSchemas| in the main directory, as well as removing all modules' generated files. Note: to be able to delete files, they cannot be in use (obviously), so close them first.

